<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Single | Sentinel2 NDVI - RGB</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Leaflet.draw for bbox selection -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <!-- Chart.js for time series plot -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- Turf.js for geometry coverage calculations -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <style>
    html,
    body,
    #map {
      height: 100%;
      margin: 0
    }

    .toolbar {
      position: absolute;
      z-index: 1000;
      top: 10px;
      right: 10px;
      left: auto;
      background: #fff;
      padding: 8px 10px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, .15);
      font: 13px system-ui, sans-serif;
    }

    .toolbar button {
      margin: 2px 0;
      width: 190px
    }

    .busy {
      position: absolute;
      z-index: 1100;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      right: auto;
      background: rgba(0, 0, 0, .75);
      color: #fff;
      padding: 10px 14px;
      border-radius: 6px;
      font: 13px system-ui, sans-serif;
      font-size: 16px;
      font-weight: 600;
      text-align: center;
      line-height: 1.3;
      display: none;
    }

    .info-panel {
      position: absolute;
      z-index: 1000;
      right: 10px;
      bottom: 70px;
      background: #fff;
      padding: 8px 10px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, .15);
      font: 13px system-ui, sans-serif;
      min-width: 220px;
      display: none;
    }

    .left-panel {
      position: absolute;
      z-index: 1000;
      left: 10px;
      top: 200px;
      background: #fff;
      padding: 12px 14px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, .15);
      font: 13px system-ui, sans-serif;
      width: 550px;
      max-height: 30%;
      overflow: auto;
      display: none;
    }

    .hint {
      position: absolute;
      z-index: 900;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      color: #333;
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
      font: 14px system-ui, sans-serif;
    }

    /* NDVI crop-stress legend */
    .ndvi-legend {
      position: absolute;
      z-index: 1000;
      left: 10px;
      bottom: 10px;
      background: #fff;
      padding: 8px 10px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, .15);
      font: 12px system-ui, sans-serif;
      display: none;
      min-width: 240px;
    }
    .ndvi-legend-title {
      font-weight: 600;
      margin-bottom: 6px;
    }
    .ndvi-gradient {
      height: 12px;
      width: 240px;
      border-radius: 6px;
      background: linear-gradient(to right,
        #a50026 0%,  #d73027 10%, #f46d43 20%, #fdae61 35%,
        #fee08b 45%, #ffffbf 50%, #d9ef8b 60%, #a6d96a 75%,
        #66bd63 85%, #1a9850 100%);
      border: 1px solid rgba(0,0,0,0.15);
    }
    .ndvi-legend-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      color: #333;
    }
    .ndvi-legend-extremes {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      color: #333;
      font-size: 11px;
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <div class="toolbar">
    <button id="btnToggle" disabled>Toggle NDVI / RGB</button><br />
    <button id="btnClearAOI" style="margin-top:6px" disabled>Clear AOI</button><br />
    <button id="btnExportAOI" style="margin-top:6px; display:none" disabled>Export AOI (GeoJSON)</button><br />
    <button id="btnExportTS" style="margin-top:6px; display:none" disabled>Export Time Series (CSV)</button><br />
  </div>
  <div id="busy" class="busy">Querying data, please wait ...</div>
  <div id="hint" class="hint">Draw a rectangle or polygon AOI to start.</div>
  <div id="info" class="info-panel"></div>
  <div id="leftPanel" class="left-panel">
    <div style="font-weight:600; margin-bottom:6px">NDVI Time Series (AOI mean)</div>
    <canvas id="ndviChart" width="550" height="250"></canvas>
  </div>

  <!-- NDVI crop-stress legend (visible when NDVI layer is shown) -->
  <div id="ndviLegend" class="ndvi-legend">
    <div class="ndvi-legend-title">Crop Stress (NDVI)</div>
    <div class="ndvi-gradient"></div>
    <div class="ndvi-legend-labels">
      <span id="ndviMin">-1.0</span>
      <span id="ndviMid">0.0</span>
      <span id="ndviMax">1.0</span>
    </div>
    <div class="ndvi-legend-extremes">
      <span>High stress (low NDVI)</span>
      <span>Low stress (high NDVI)</span>
    </div>
  </div>

  <script>
    // Config
    const COLLECTION = "sentinel-2-l2a";
    const ITEM_BASE = "https://planetarycomputer.microsoft.com/api/data/v1/item/tilejson.json";

    function buildItemUrls(itemId, bbox, rescaleStr) {
      const bboxParam = bbox && bbox.length === 4 ? `&bbox=${bbox.join(',')}` : '';
      const trueUrl = `${ITEM_BASE}?collection=${encodeURIComponent(COLLECTION)}&item=${encodeURIComponent(itemId)}&assets=visual&asset_bidx=visual%7C1%2C2%2C3&nodata=0&format=png${bboxParam}`;
      const rescale = rescaleStr || '-1,1';
      const ndviUrl = `${ITEM_BASE}?collection=${encodeURIComponent(COLLECTION)}&item=${encodeURIComponent(itemId)}&expression=${encodeURIComponent('(B08-B04)/(B08+B04)')}&rescale=${encodeURIComponent(rescale)}&colormap_name=rdylgn&asset_as_band=true${bboxParam}`;
      return { trueUrl, ndviUrl };
    }

    function randomBboxInCamargue() {
      const W = 4.2, E = 4.8, S = 43.3, N = 43.6;
      const width = 0.18, height = 0.12;
      const cx = W + 0.1 + Math.random() * (E - W - 0.2);
      const cy = S + 0.06 + Math.random() * (N - S - 0.12);
      const w = cx - width / 2, e = cx + width / 2, s = cy - height / 2, n = cy + height / 2;
      return [w, s, e, n];
    }

    // Map init
    const map = L.map('map').setView([0, 0], 2);
    L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
      { attribution: "Tiles © Esri — World Imagery" }).addTo(map);

    // State
    let trueLayer = null, ndviLayer = null, didFit = false;
    let cropBounds = null, drawnBox = null, hasScene = false;
    let aoiPaneName = 'aoiPane';
    let aoiRingLatLng = null; // polygon ring for clipping
    let showingNdvi = true;
    let ndviChart = null;
    let TS_DATA = null; // { labels: string[], values: number[] }
    let CURRENT_ID = null; // string
    let CURRENT_META = null; // { id, cloud, datetime }
    const COVERAGE_THRESHOLD = 0.95; // Require >= 95% AOI coverage

    async function getTileJSON(url) {
      const r = await fetch(url);
      if (!r.ok) throw new Error(`TileJSON failed ${r.status}`);
      const tj = await r.json();
      if (!tj.tiles || !tj.tiles[0]) throw new Error("No 'tiles' in TileJSON");
      return tj;
    }

    function ensureAoiPane() {
      if (!map.getPane(aoiPaneName)) {
        map.createPane(aoiPaneName);
        const pane = map.getPane(aoiPaneName);
        pane.style.zIndex = 350; // above basemap
      }
    }

    function addFromTileJSON(tj, opts = {}) {
      ensureAoiPane();
      const layer = L.tileLayer(tj.tiles[0], {
        attribution: tj.attribution || 'Microsoft Planetary Computer, Copernicus',
        minZoom: tj.minzoom ?? undefined,
        maxZoom: tj.maxzoom ?? undefined,
        bounds: cropBounds ?? undefined,
        pane: aoiPaneName,
        ...opts
      });
      if (!didFit) {
        if (cropBounds) {
          map.fitBounds(cropBounds, { maxZoom: tj.maxzoom ?? 12 });
          didFit = true;
        } else if (Array.isArray(tj.bounds) && tj.bounds.length === 4) {
          const [w, s, e, n] = tj.bounds;
          map.fitBounds([[s, w], [n, e]], { maxZoom: tj.maxzoom ?? 12 });
          didFit = true;
        }
      }
      return layer;
    }

    // Helpers and clip function to support polygon AOIs
    function latLngsFromRectangle(layer) {
      const b = layer.getBounds();
      const sw = b.getSouthWest();
      const ne = b.getNorthEast();
      const nw = L.latLng(ne.lat, sw.lng);
      const se = L.latLng(sw.lat, ne.lng);
      return [sw, se, ne, nw];
    }

    function ringFromLayer(layer) {
      if (layer instanceof L.Rectangle) return latLngsFromRectangle(layer);
      if (layer instanceof L.Polygon) {
        const rings = layer.getLatLngs();
        const outer = Array.isArray(rings) ? (Array.isArray(rings[0]) ? rings[0] : rings) : [];
        return outer.map(ll => L.latLng(ll.lat, ll.lng));
      }
      return null;
    }

    function toGeoJSONPolygon(ring) {
      if (!ring || !ring.length) return null;
      const coords = ring.map(ll => [ll.lng, ll.lat]);
      const first = coords[0];
      const last = coords[coords.length - 1];
      if (first[0] !== last[0] || first[1] !== last[1]) coords.push(first);
      return { type: 'Polygon', coordinates: [coords] };
    }

    function updateAoiClip() {
      const pane = map.getPane(aoiPaneName);
      if (!pane) return;
      if (!aoiRingLatLng || !aoiRingLatLng.length) { pane.style.clipPath = ''; pane.style.webkitClipPath = ''; return; }
      const pts = aoiRingLatLng.map(ll => map.latLngToLayerPoint(ll));
      const poly = 'polygon(' + pts.map(p => `${p.x}px ${p.y}px`).join(',') + ')';
      pane.style.clipPath = poly;
      pane.style.webkitClipPath = poly;
    }

    function showOnly(layerToShow) {
      [trueLayer, ndviLayer].forEach(l => { if (l && map.hasLayer(l)) map.removeLayer(l); });
      if (layerToShow) layerToShow.addTo(map);
      updateAoiClip();
    }

    function setLegendVisible(visible) {
      const el = document.getElementById('ndviLegend');
      if (!el) return;
      el.style.display = visible ? 'block' : 'none';
    }

    function updateLegendScale(minVal, maxVal) {
      const fmt = (v) => (Math.abs(v) >= 1 ? v.toFixed(1) : v.toFixed(2));
      const minEl = document.getElementById('ndviMin');
      const midEl = document.getElementById('ndviMid');
      const maxEl = document.getElementById('ndviMax');
      if (minEl) minEl.textContent = fmt(minVal);
      if (maxEl) maxEl.textContent = fmt(maxVal);
      const mid = (minVal + maxVal) / 2;
      if (midEl) midEl.textContent = fmt(mid);
    }

    function clamp01Range(minVal, maxVal) {
      let a = Math.max(-1, Math.min(1, Number(minVal)));
      let b = Math.max(-1, Math.min(1, Number(maxVal)));
      if (!Number.isFinite(a) || !Number.isFinite(b)) return [-1, 1];
      if (a === b) { a = a - 0.01; b = b + 0.01; }
      if (a > b) [a, b] = [b, a];
      return [a, b];
    }

    async function fetchNdviStats(itemId, geometry) {
      const params = new URLSearchParams();
      params.set('collection', COLLECTION);
      params.set('item', itemId);
      params.set('expression', '(B08-B04)/(B08+B04)');
      params.set('asset_as_band', 'true');
      params.set('rescale', '-1,1');
      if (geometry) params.set('geometry', JSON.stringify(geometry));
      const url = `${STAT_BASE}?${params.toString()}`;
      const r = await fetch(url);
      if (!r.ok) throw new Error(`Stats failed ${r.status}`);
      const json = await r.json();
      const keys = Object.keys(json || {});
      let node = null;
      if (keys.length) node = json[keys[0]];
      if (!node && json && json.statistics) node = json;
      const stats = node && node.statistics ? node.statistics : node || {};
      const p2 = Number(stats.percentile_2 ?? stats['2%']);
      const p98 = Number(stats.percentile_98 ?? stats['98%']);
      const min = Number(stats.min);
      const max = Number(stats.max);
      return { p2, p98, min, max };
    }

    function pickRescale(stats) {
      if (!stats) return [-1, 1];
      let a = stats.p2, b = stats.p98;
      if (Number.isFinite(a) && Number.isFinite(b) && a < b) return clamp01Range(a, b);
      a = stats.min; b = stats.max;
      if (Number.isFinite(a) && Number.isFinite(b) && a < b) return clamp01Range(a, b);
      return [-1, 1];
    }

    function buildCurrentAoiGeometry() {
      if (aoiRingLatLng && aoiRingLatLng.length) {
        const coords = aoiRingLatLng.map(ll => [ll.lng, ll.lat]);
        const first = coords[0];
        const last = coords[coords.length - 1];
        if (first[0] !== last[0] || first[1] !== last[1]) coords.push(first);
        return { type: 'Polygon', coordinates: [coords] };
      }
      if (cropBounds) {
        const sw = cropBounds.getSouthWest(); const ne = cropBounds.getNorthEast();
        return { type: 'Polygon', coordinates: [[[sw.lng, sw.lat], [ne.lng, sw.lat], [ne.lng, ne.lat], [sw.lng, ne.lat], [sw.lng, sw.lat]]] };
      }
      return null;
    }

    function setToggleEnabled(enabled) {
      document.getElementById('btnToggle').disabled = !enabled;
    }

    function clearAOIAndData() {
      // Remove drawn AOI
      if (drawnBox) { map.removeLayer(drawnBox); }
      drawnBox = null;
      cropBounds = null;
      aoiRingLatLng = null;
      updateAoiClip();

      // Remove imagery layers
      showOnly(null);
      trueLayer = null;
      ndviLayer = null;
      hasScene = false;
      setToggleEnabled(false);
      setLegendVisible(false);

      // Clear info panel
      const info = document.getElementById('info');
      info.innerHTML = '';
      info.style.display = 'none';

      // Clear NDVI chart and hide panel
      const panel = document.getElementById('leftPanel');
      if (ndviChart) { try { ndviChart.destroy(); } catch { } }
      ndviChart = null;
      panel.style.display = 'none';

      // Reset current selection meta
      CURRENT_META = null;
      CURRENT_ID = null;

      // Show the hint again
      const hint = document.getElementById('hint');
      if (hint) hint.style.display = 'block';

      // Hide/disable time series export
      TS_DATA = null;
      const btnTS = document.getElementById('btnExportTS');
      if (btnTS) { btnTS.disabled = true; btnTS.style.display = 'none'; }
      // Hide/disable AOI export
      const btnAOI = document.getElementById('btnExportAOI');
      if (btnAOI) { btnAOI.disabled = true; btnAOI.style.display = 'none'; }
      // Disable Clear AOI button
      const btnClear = document.getElementById('btnClearAOI');
      if (btnClear) btnClear.disabled = true;
    }

    function formatDate(iso) {
      if (!iso) return '';
      try { return new Date(iso).toLocaleString(); } catch { return iso; }
    }

    function updateInfo(meta) {
      const panel = document.getElementById('info');
      if (!meta) { panel.style.display = 'none'; panel.innerHTML = ''; return; }
      const cloudStr = typeof meta.cloud === 'number' ? `${meta.cloud.toFixed(1)}%` : 'n/a';
      const covStr = typeof meta.coverage === 'number' ? `${(meta.coverage * 100).toFixed(1)}%` : 'n/a';
      panel.innerHTML = `
          <div><strong>Info: S2 Scene (in display)</strong></div>
          <div style="margin-top:6px">
            <div style="word-break: break-all">${meta.id}</div>
            <div><strong>Date:</strong> ${formatDate(meta.datetime)}</div>
            <div><strong>Cloud:</strong> ${cloudStr}</div>
            <div><strong>AOI Coverage:</strong> ${covStr} (≥ ${(COVERAGE_THRESHOLD * 100) | 0}% required)</div>
          </div>`;
      panel.style.display = 'block';
    }

    async function setLayersForItem(itemId, bbox, meta) {
      didFit = false;
      // Compute dynamic NDVI rescale over AOI
      let rescaleStr = '-1,1';
      try {
        const geom = buildCurrentAoiGeometry();
        const stats = await fetchNdviStats(itemId, geom);
        const [rmin, rmax] = pickRescale(stats);
        rescaleStr = `${rmin},${rmax}`;
        updateLegendScale(rmin, rmax);
      } catch (e) {
        console.warn('NDVI dynamic rescale failed; using default', e);
        updateLegendScale(-1, 1);
      }
      const { trueUrl, ndviUrl } = buildItemUrls(itemId, bbox, rescaleStr);
      const [tjTrue, tjNdvi] = await Promise.all([getTileJSON(trueUrl), getTileJSON(ndviUrl)]);

      showOnly(null);
      trueLayer = addFromTileJSON(tjTrue);
      ndviLayer = addFromTileJSON(tjNdvi, { opacity: 0.9 });
      showOnly(ndviLayer); // NDVI by default
      updateAoiClip();
      setLegendVisible(true);

      hasScene = true;
      setToggleEnabled(true);
      updateInfo(meta || CURRENT_META);
      const hintEl = document.getElementById('hint');
      if (hintEl) hintEl.style.display = 'none';
      // Update NDVI time series over all scenes in last 6 months
      try { await updateNdviTimeseriesAll(); } catch (e) { console.warn('NDVI timeseries update failed', e); }
    }

    function setBusy(isBusy) {
      const el = document.getElementById('busy');
      el.style.display = isBusy ? 'block' : 'none';
      document.getElementById('btnToggle').disabled = isBusy || !hasScene;
    }

    function getSearchParams() {
      const now = new Date();
      const sixMonthsMs = 183 * 24 * 3600 * 1000; // ~6 months
      const start = new Date(now.getTime() - sixMonthsMs);
      return { startIso: start.toISOString(), endIso: now.toISOString() };
    }

    function polygonFromBbox(bbox) {
      if (!Array.isArray(bbox) || bbox.length !== 4) return null;
      const [w, s, e, n] = bbox;
      return { type: 'Polygon', coordinates: [[[w, s], [e, s], [e, n], [w, n], [w, s]]] };
    }

    function getAoiGeometry(aoi) {
      if (!aoi) return null;
      if (aoi.intersects) return aoi.intersects; // already a polygon geometry
      if (aoi.bbox) return polygonFromBbox(aoi.bbox);
      return null;
    }

    function computeCoverageFraction(aoiGeom, itemGeom) {
      try {
        if (!aoiGeom || !itemGeom || !turf) return null;
        const aoiFeat = turf.feature(aoiGeom);
        const itemFeat = turf.feature(itemGeom);
        const aArea = turf.area(aoiFeat);
        if (!aArea || aArea <= 0) return null;
        const inter = turf.intersect(aoiFeat, itemFeat);
        if (!inter) return 0;
        const iArea = turf.area(inter);
        return iArea / aArea;
      } catch (e) {
        console.warn('Coverage computation failed', e);
        return null;
      }
    }

    async function searchBestLeastCloud(aoi) {
      const { startIso, endIso } = getSearchParams();
      const url = 'https://planetarycomputer.microsoft.com/api/stac/v1/search';
      const where = aoi && aoi.intersects
        ? { intersects: aoi.intersects }
        : (aoi && aoi.bbox ? { bbox: aoi.bbox } : {});
      const body = {
        collections: [COLLECTION],
        ...where,
        limit: 200,
        datetime: `${startIso}/${endIso}`,
        sortby: [
          { field: 'properties.eo:cloud_cover', direction: 'asc' },
          { field: 'properties.datetime', direction: 'desc' }
        ],
        // Sort by least cloud; we'll then enforce coverage ≥ threshold
      };
      const r = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      if (!r.ok) throw new Error(`STAC search failed ${r.status}`);
      const json = await r.json();
      const feats = (json.features || []);
      if (!feats.length) throw new Error('No Sentinel-2 items found in AOI');

      // Compute coverage for each feature in order; pick first meeting threshold
      const aoiGeom = getAoiGeometry(aoi);
      let best = null;
      for (const f of feats) {
        const cov = aoiGeom ? computeCoverageFraction(aoiGeom, f.geometry) : null;
        const meta = { id: f.id, cloud: f.properties?.['eo:cloud_cover'], datetime: f.properties?.datetime, coverage: cov };
        if (cov != null && cov >= COVERAGE_THRESHOLD) {
          best = meta;
          break; // first that meets threshold due to sort order
        }
        if (!best) best = meta; // fallback to the first while searching
      }
      if (best && (best.coverage == null || best.coverage < COVERAGE_THRESHOLD)) {
        console.warn(`No scene covers ≥ ${COVERAGE_THRESHOLD * 100}% of AOI; falling back to least-cloud scene.`);
      }
      return best;
    }

    // ===== NDVI Time Series over AOI (all scenes in last 6 months) =====
    const STAT_BASE = "https://planetarycomputer.microsoft.com/api/data/v1/item/statistics";

    function formatDateShort(iso) { try { return new Date(iso).toLocaleDateString(); } catch { return iso; } }

    function buildStatsUrl(itemId, geometry) {
      const params = new URLSearchParams();
      params.set('collection', COLLECTION);
      params.set('item', itemId);
      params.set('expression', '(B08-B04)/(B08+B04)');
      params.set('asset_as_band', 'true');
      params.set('rescale', '-1,1');
      if (geometry) params.set('geometry', JSON.stringify(geometry));
      return `${STAT_BASE}?${params.toString()}`;
    }

    function extractMeanFromStats(statsJson) {
      if (!statsJson || typeof statsJson !== 'object') return null;
      const keys = Object.keys(statsJson);
      if (keys.length) {
        const node = statsJson[keys[0]];
        if (node) {
          if (typeof node.mean === 'number') return node.mean;
          if (node.statistics && typeof node.statistics.mean === 'number') return node.statistics.mean;
        }
      }
      if (statsJson.statistics && typeof statsJson.statistics.mean === 'number') return statsJson.statistics.mean;
      return null;
    }

    async function fetchNdviMean(itemId, geometry) {
      const url = buildStatsUrl(itemId, geometry);
      const r = await fetch(url);
      if (!r.ok) throw new Error(`Stats failed ${r.status}`);
      const json = await r.json();
      const mean = extractMeanFromStats(json);
      if (typeof mean !== 'number' || Number.isNaN(mean)) throw new Error('No mean in stats');
      return mean;
    }

    async function searchAllScenesForTimeseries(aoi) {
      const { startIso, endIso } = getSearchParams();
      const url = 'https://planetarycomputer.microsoft.com/api/stac/v1/search';
      const where = aoi && aoi.intersects ? { intersects: aoi.intersects } : (aoi && aoi.bbox ? { bbox: aoi.bbox } : {});
      const body = {
        collections: [COLLECTION],
        ...where,
        limit: 200,
        datetime: `${startIso}/${endIso}`,
        sortby: [{ field: 'properties.datetime', direction: 'asc' }]
      };
      const r = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      if (!r.ok) throw new Error(`STAC search failed ${r.status}`);
      const json = await r.json();
      const feats = (json.features || []);
      return feats.map(f => ({ id: f.id, datetime: f.properties?.datetime }));
    }

    async function updateNdviTimeseries(metas) {
      const panel = document.getElementById('leftPanel');
      const canvas = document.getElementById('ndviChart');
      if (!Array.isArray(metas) || metas.length === 0) { panel.style.display = 'none'; return; }
      // Build AOI geometry
      let geom = null;
      if (aoiRingLatLng && aoiRingLatLng.length) {
        const coords = aoiRingLatLng.map(ll => [ll.lng, ll.lat]);
        const first = coords[0];
        const last = coords[coords.length - 1];
        if (first[0] !== last[0] || first[1] !== last[1]) coords.push(first);
        geom = { type: 'Polygon', coordinates: [coords] };
      } else if (cropBounds) {
        const sw = cropBounds.getSouthWest(); const ne = cropBounds.getNorthEast();
        geom = { type: 'Polygon', coordinates: [[[sw.lng, sw.lat], [ne.lng, sw.lat], [ne.lng, ne.lat], [sw.lng, ne.lat], [sw.lng, sw.lat]]] };
      }
      const means = await Promise.all(metas.map(m => fetchNdviMean(m.id, geom).catch(() => null)));
      const labels = metas.map(m => formatDateShort(m.datetime));
      // store for export
      TS_DATA = { labels, values: means };
      const btnTS = document.getElementById('btnExportTS');
      if (btnTS) { btnTS.style.display = 'inline-block'; btnTS.disabled = false; }
      const data = { labels, datasets: [{ label: 'Mean NDVI', data: means, borderColor: '#43a047', backgroundColor: 'rgba(67,160,71,0.25)', pointBackgroundColor: '#2e7d32', pointRadius: 4, showLine: true, tension: 0.2 }] };
      const cfg = { type: 'line', data, options: { responsive: false, scales: { y: { suggestedMin: -0.2, suggestedMax: 1.0, title: { display: true, text: 'NDVI' } }, x: { title: { display: true, text: 'Date' } } }, plugins: { legend: { display: false } } } };
      if (ndviChart) ndviChart.destroy();
      ndviChart = new Chart(canvas.getContext('2d'), cfg);
      panel.style.display = 'block';
    }

    function exportTimeseriesCSV() {
      if (!TS_DATA || !Array.isArray(TS_DATA.labels) || !Array.isArray(TS_DATA.values)) return;
      const rows = ['Date,Mean_NDVI'];
      for (let i = 0; i < TS_DATA.labels.length; i++) {
        const d = TS_DATA.labels[i] ?? '';
        const v = TS_DATA.values[i];
        const val = (typeof v === 'number' && !Number.isNaN(v)) ? v : '';
        rows.push(`${d},${val}`);
      }
      const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ndvi_timeseries.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function updateNdviTimeseriesAll() {
      const bbox = cropBounds ? bboxFromLatLngBounds(cropBounds) : null;
      const intersects = toGeoJSONPolygon(aoiRingLatLng);
      const aoi = intersects ? { intersects, bbox } : (bbox ? { bbox } : null);
      if (!aoi) return;
      const metasAll = await searchAllScenesForTimeseries(aoi);
      await updateNdviTimeseries(metasAll);
    }

    function bboxFromLatLngBounds(llb) {
      const sw = llb.getSouthWest();
      const ne = llb.getNorthEast();
      return [sw.lng, sw.lat, ne.lng, ne.lat];
    }

    function drawInit() {
      const drawControl = new L.Control.Draw({
        position: 'topleft',
        draw: {
          polygon: { allowIntersection: false, showArea: true, shapeOptions: { color: '#e91e63', fillOpacity: 0.05 } },
          polyline: false, circle: false, marker: false, circlemarker: false,
          rectangle: { shapeOptions: { color: '#e91e63', fillOpacity: 0.05 } }
        },
        edit: false
      });
      map.addControl(drawControl);

      map.on(L.Draw.Event.CREATED, async (e) => {
        try {
          // Hide hint when AOI is activated
          const hintEl = document.getElementById('hint');
          if (hintEl) hintEl.style.display = 'none';
          // Enable Clear AOI button
          const btnClear = document.getElementById('btnClearAOI');
          if (btnClear) btnClear.disabled = false;
          // Show/enable Export AOI button
          const btnAOI = document.getElementById('btnExportAOI');
          if (btnAOI) { btnAOI.style.display = 'inline-block'; btnAOI.disabled = false; }
          if (drawnBox) map.removeLayer(drawnBox);
          drawnBox = e.layer.addTo(map);
          cropBounds = drawnBox.getBounds();
          aoiRingLatLng = ringFromLayer(drawnBox) || null;
          updateAoiClip();
          const bbox = bboxFromLatLngBounds(cropBounds);
          const intersects = toGeoJSONPolygon(aoiRingLatLng);
          const aoi = intersects ? { intersects, bbox } : { bbox };
          setBusy(true);
          const meta = await searchBestLeastCloud(aoi);
          CURRENT_ID = meta.id; CURRENT_META = meta;
          await setLayersForItem(CURRENT_ID, bbox, CURRENT_META);
          console.log('Selected item', meta);
        } catch (err) {
          console.error(err);
          alert(err.message || err);
        } finally { setBusy(false); }
      });
    }

    (async () => {
      // Buttons
      document.getElementById('btnToggle').onclick = () => {
        if (!trueLayer || !ndviLayer) return;
        showingNdvi = !showingNdvi;
        showOnly(showingNdvi ? ndviLayer : trueLayer);
        setLegendVisible(showingNdvi);
      };

      const btnTS = document.getElementById('btnExportTS');
      btnTS.onclick = () => exportTimeseriesCSV();

      // Clear AOI and all loaded data
      document.getElementById('btnClearAOI').onclick = () => {
        clearAOIAndData();
      };

      // Export AOI (GeoJSON)
      document.getElementById('btnExportAOI').onclick = () => {
        if (!drawnBox) { alert('No AOI to export. Draw a rectangle or polygon first.'); return; }
        const ring = ringFromLayer(drawnBox);
        const geom = toGeoJSONPolygon(ring);
        if (!geom) { alert('AOI geometry unavailable.'); return; }
        const bounds = drawnBox.getBounds();
        const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
        const feature = {
          type: 'Feature',
          properties: { name: 'AOI', source: 'best_scene.html' },
          bbox,
          geometry: geom
        };
        const blob = new Blob([JSON.stringify(feature, null, 2)], { type: 'application/geo+json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'aoi.geojson';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      };

      // Enable drawing a bbox to refine search and clip
      drawInit();

      // Start location: Yemen highlands (agricultural areas), no AOI drawn
      map.setView([15.4, 44.2], 10);
      // keep clip in sync with map movements
      ['move', 'zoom', 'zoomend', 'resize', 'viewreset'].forEach(ev => map.on(ev, updateAoiClip));
      // Ensure legend hidden initially
      setLegendVisible(false);
    })().catch(err => { console.error(err); alert(err.message || err); });
  </script>
</body>

</html>
